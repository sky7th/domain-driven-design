### [Domain-Driven Design의 적용](http://aeternum.egloos.com/m/1105776) 시리즈를 공부하며 정리한 저장소입니다.


# PART 1. VALUE OBJECT와 REFERENCE OBJECT

## 동일함(identical)의 의미
어플리케이션을 구성하는 객체
- REFERENCE OBJECT
  - 고객, 주문과 같이 실 세계의 추적 가능한 개념을 표현
  - 시스템 내에서 해당 객체를 계속 추적해야 하는가? 
  - 객체가 표현하는 개념이 유일하게 하나만 존재해야 하는가?
  - 각 고객이 유일하기 때문에 고객이 동일한 지를 판단하기 위해 메모리 주소를 비교하는 “==” 연산자를 사용한다. (동일성)
- VALUE OBJECT
  - 날짜, 금액과 같은 것들이며 단지 객체를 구성하는 속성들의 값에만 초점을 맞출 뿐 객체의 추적성에는 관심을 두지 않는다.
  - 속성값이 동일하면 동일한 객체로 간주해도 무방한가?
  - equals() 메소드를 오버라이딩하여 금액의 동등성을 테스트해야 한다. equals() 메소드를 오버라이딩 할 경우에는 hashCode() 메소드도 함께 오버라이딩해주는 것이 좋다.

REFERENCE OBJECT와 VALUE OBJECT를 구별하는 이유는 REFERENCE OBJECT 대신 VALUE OBJECT를 사용함으로써 악명 높은 별칭(aliasing) 문제를 피할 수 있기 때문이다.

 ## 별칭(aliasing) 문제
동일한 객체를 서로 다른 변수가 참조하는 것을 별칭(aliasing)이라고 한다.

동일한 메소드, 동일한 클래스 내에서라면 의식적으로 별칭을 만들지 않을 수 있으나 해당 객체를 다른 메소드의 인자로 전달하는 순간 별칭 문제가 생기게 된다.

메소드를 호출하는 순간 전달된 인자에 대한 별칭이 자동으로 생성된다.

**인자로 전달된 객체의 상태를 바꾸는 메소드는 작성하지 말자.**

가능한 방어적으로 프로그래밍해야 한다.

**별칭 문제를 해결하기 위한 가장 좋은 방법은 객체를 변경할 수 없는 불변 상태로 만드는 것이다.**

전달된 객체가 변경될 수 없다면 메소드에 객체를 전달한다고 하더라도 별칭을 통한 부작용을 막을 수 있다.

## 불변성
#### 불변 클래스는 다음과 같은 규칙을 따른다.
- 객체를 변경하는 메소드를 제공하지 않는다.
- 재정의할 수 있는 메소드를 제공하지 않는다.
- 모든 필드를 final로 만든다.
- 모든 필드를 private으로 만든다.
- 가변 객체를 참조하는 필드는 배타적으로 접근해야 한다.

### VALUE OBJECT와 불변성
객체의 상태를 바꿀 수는 없으므로 새로운 상태로 변경해야 할 경우 **새로운 불변 객체를 만들어 기존의 불변 객체를 대체 시켜야 한다.**

VALUE OBJECT는 일반적으로 날짜, 금액과 같이 작은 개념을 의미하기 때문에 새로운 객체를 만들어 대체할 경우의 오버헤드가 적다. 

풍부한 도메인 모델의 작성을 위해서는 유용하지만 비즈니스 적인 관점에서 가치가 없는 작은 개념을 VALUE OBJECT로 모델링하자.

REFERENCE OBJECT에 대한 별칭 문제는 피할 수 없다. **REFERENCE OBJECT에 있어 별칭은 문제가 아니라 요구사항이다.** 즉, 시스템은 REFERENCE OBJECT의 변경 사항을 추적해야 한다.

만약 대상이 최초 생성 시에 설정된 속성이 그대로 유지되는 추적 가능한 도메인 개념이라면 불변성을 가진 REFERENCE OBJECT로 취급하자.

**가능하다면 불변 객체로 시작하라.** 만약 객체에 대한 변경 사항이 시스템의 다른 부분으로 전파될 필요가 있다면 이를 가변 객체로 변경하라.

**REFERENCE OBJECT를 불변으로 만드는 유일한 방법**은 REFERENCE OBJECT의 인터페이스에 **상태를 변경하는 메소드를 포함시키지 않는 것**이다.

**REFERENCE OBJECT를 다룰 때는 오직 하나의 객체만이 생성**되고 동일한 객체를 시스템의 필요 부분으로 전달하기 위한 생명 주기 제어 메커니즘이 필요하다.

## 생명 주기 제어
특정한 작업을 수행하기 위해서는 얽히고 설킨 수 많은 객체들 중 어떤 객체에서 항해를 시작할 것인지를 결정해야 한다.

객체 그래프 상에서 항해를 시작하기 위한 시작 객체를 ENTRY POINT라고 한다. 객체 그룹의 ENTRY POINT는 항상 REFERENCE OBJECT여야 한다.

사용자 요청이 시스템 내에 도착하면 시스템은 요청을 처리할 객체 그룹을 찾는다. 이 객체 그룹 중 ENTRY POINT에 해당하는 REFERENCE OBJECT가 그룹을 대표하여 요청을 전달받고 작업을 수행하기 위해 필요한 객체들과의 협력을 통해 요청을 완수한다.

시스템은 임의의 ENTRY POINT에 접근 가능해야 한다. 또한 ENTRY POINT는 REFERENCE OBJECT이므로 ENTRY POINT에 접근할 때마다 동일한 객체 인스턴스를 반환 받아야 한다.

이처럼 ENTRY POINT의 유일성과 추적성을 유지하기 위해서는 ENTRY POINT를 관리하는 특별한 객체가 필요하다. 이 특별한 객체는 특정한 ENTRY POINT의 목록을 유지하고 클라이언트에 ENTRY POINT에 대한 관리 인터페이스를 제공한다. 즉 ENTRY POINT와 관련된 추가, 수정, 삭제, 조회 등의 컬렉션 처리를 수행한다.

ENTRY POINT에 대한 관리 인터페이스를 구성하는 방법에는 두 가지가 존재한다.
- 각각의 ENTRY POINT가 스스로 관리 인터페이스를 제공한다.
- 별도의 객체가 ENTRY POINT에 대한 관리 인터페이스를 제공한다.

두 방법 모두 생성된 ENTRY POINT를 메모리 내에서 검색하기 위한 메커니즘을 필요로 한다.   이를 처리하기 위해 ENTRY POINT는 메모리 내에서 자신을 손쉽게 검색할 수 있도록 검색 키를 제공해야 한다.

코드를 작성하기 전에 테스트를 작성하는 것은 좋은 습관이다.

