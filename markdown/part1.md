### [Domain-Driven Design의 적용](http://aeternum.egloos.com/m/1105776) 시리즈를 공부하며 정리한 내용입니다.

### [예제](https://github.com/sky7th/domain-driven-design/tree/master/src/main/java/com/sky7th/domaindrivendesign/part1)

# PART 1. VALUE OBJECT와 REFERENCE OBJECT

## 동일함(identical)의 의미
### 어플리케이션을 구성하는 객체
- **REFERENCE OBJECT**
  - 고객, 주문과 같이 실 세계의 추적 가능한 개념을 표현
  - 시스템 내에서 해당 객체를 계속 추적해야 하는가? 
  - 객체가 표현하는 개념이 유일하게 하나만 존재해야 하는가?
  - 각 고객이 유일하기 때문에 고객이 동일한 지를 판단하기 위해 메모리 주소를 비교하는 “==” 연산자를 사용한다. (동일성)
- **VALUE OBJECT**
  - 날짜, 금액과 같은 것들이며 단지 객체를 구성하는 속성들의 값에만 초점을 맞출 뿐 객체의 추적성에는 관심을 두지 않는다.
  - 속성값이 동일하면 동일한 객체로 간주해도 무방한가?
  - equals() 메소드를 오버라이딩하여 금액의 동등성을 테스트해야 한다. equals() 메소드를 오버라이딩 할 경우에는 hashCode() 메소드도 함께 오버라이딩해주는 것이 좋다.

REFERENCE OBJECT와 VALUE OBJECT를 구별하는 이유는 REFERENCE OBJECT 대신 VALUE OBJECT를 사용함으로써 악명 높은 별칭(aliasing) 문제를 피할 수 있기 때문이다.

 ## 별칭(aliasing) 문제
동일한 객체를 서로 다른 변수가 참조하는 것을 별칭(aliasing)이라고 한다.

동일한 메소드, 동일한 클래스 내에서라면 의식적으로 별칭을 만들지 않을 수 있으나 해당 객체를 다른 메소드의 인자로 전달하는 순간 별칭 문제가 생기게 된다.

메소드를 호출하는 순간 전달된 인자에 대한 별칭이 자동으로 생성된다.

**인자로 전달된 객체의 상태를 바꾸는 메소드는 작성하지 말자.**

가능한 방어적으로 프로그래밍해야 한다.

**별칭 문제를 해결하기 위한 가장 좋은 방법은 객체를 변경할 수 없는 불변 상태로 만드는 것이다.**

전달된 객체가 변경될 수 없다면 메소드에 객체를 전달한다고 하더라도 별칭을 통한 부작용을 막을 수 있다.

## 불변성
### 불변 클래스는 다음과 같은 규칙을 따른다.
- 객체를 변경하는 메소드를 제공하지 않는다.
- 재정의할 수 있는 메소드를 제공하지 않는다.
- 모든 필드를 final로 만든다.
- 모든 필드를 private으로 만든다.
- 가변 객체를 참조하는 필드는 배타적으로 접근해야 한다.

### VALUE OBJECT와 불변성
객체의 상태를 바꿀 수는 없으므로 새로운 상태로 변경해야 할 경우 **새로운 불변 객체를 만들어 기존의 불변 객체를 대체 시켜야 한다.**

- VALUE OBJECT는 새로운 객체를 만들어 대체할 경우의 오버헤드가 적다. 

풍부한 도메인 모델의 작성을 위해서는 유용하지만 비즈니스 적인 관점에서 가치가 없는 작은 개념을 VALUE OBJECT로 모델링하자.

### REFERENCE OBJECT와 불변성
**REFERENCE OBJECT에 있어 별칭은 문제가 아니라 요구사항이다.**
- REFERENCE OBJECT에 대한 별칭 문제는 피할 수 없다. 
- 즉, 시스템은 REFERENCE OBJECT의 변경 사항을 추적해야 한다.

만약 대상이 최초 **생성 시에 설정된 속성이 그대로 유지되는 추적 가능한 도메인 개념이라면 불변성을 가진 REFERENCE OBJECT로 취급하자.**

**가능하다면 불변 객체로 시작하라.**
- 만약 객체에 대한 변경 사항이 시스템의 다른 부분으로 전파될 필요가 있다면 이를 가변 객체로 변경하라.

**REFERENCE OBJECT를 불변으로 만드는 유일한 방법** 
- REFERENCE OBJECT의 인터페이스에 **상태를 변경하는 메소드를 포함시키지 않는 것**이다.

**REFERENCE OBJECT를 다룰 때는 오직 하나의 객체만이 생성**되고 동일한 객체를 시스템의 필요 부분으로 전달하기 위한 생명 주기 제어 메커니즘이 필요하다.

## 생명 주기 제어
특정한 작업을 수행하기 위해서는 **어떤 객체에서 항해를 시작할 것인지를 결정**해야 한다.

### ENTRY POINT
- 객체 그래프 상에서 시작하기 위한 시작 객체
- 객체 그룹의 ENTRY POINT는 항상 REFERENCE OBJECT여야 한다.

### 사용자 요청이 시스템 내에 도착했을 때
- 시스템은 요청을 처리할 객체 그룹을 찾는다. 
- 이 객체 그룹 중 **ENTRY POINT에 해당하는 REFERENCE OBJECT가 그룹을 대표하여 요청을 전달받는다.**
- 작업을 수행하기 위해 필요한 **객체들과의 협력을 통해 요청을 완수한다.**

시스템은 임의의 ENTRY POINT에 접근 가능해야 한다. 또한 ENTRY POINT는 REFERENCE OBJECT이므로 **ENTRY POINT에 접근할 때마다 동일한 객체 인스턴스를 반환 받아야 한다.**

이처럼 **ENTRY POINT의 유일성과 추적성을 유지하기 위해서는 ENTRY POINT를 관리하는 특별한 객체가 필요하다.** 

이 특별한 객체는 특정한 ENTRY POINT의 목록을 유지하고 클라이언트에 ENTRY POINT에 대한 관리 인터페이스를 제공한다.

### **ENTRY POINT에 대한 관리 인터페이스를 구성하는 방법**
- 각각의 ENTRY POINT가 스스로 관리 인터페이스를 제공한다.
- 별도의 객체가 ENTRY POINT에 대한 관리 인터페이스를 제공한다.

두 방법 모두 생성된 ENTRY POINT를 메모리 내에서 검색하기 위한 메커니즘을 필요로 한다. 이를 처리하기 위해 **ENTRY POINT는 메모리 내에서 자신을 손쉽게 검색할 수 있도록 검색 키를 제공해야 한다.**

## 도메인의 복잡성
복잡한 인간 세상을 담아내야 하기 때문에 소프트웨어는 복잡하다.

REFERENCE OBJECT와 VALUE OBJECT의 분리는 도메인 개념들의 추적성 및 식별성을 추상화하기 위한 분석 기법이다. 

도메인 영역의 개념을 REFERENCE OBJECT와 VALUE OBJECT로 분리함으로써 도메인의 본질적인 특성에 초점을 맞추게 된다.

**REFERENCE OBJECT를 식별함으로써 시스템의 핵심 개념들의 생명 주기에 초점을 맞출 수 있고 VALUE OBJECT를 식별함으로써 도메인의 일부지만 중요하지 않은 개념들을 걸러낼 수 있다.**

두 가지 개념이 추가되면 생각할 거리가 많아진다.
- 영속성 메커니즘
- 동시성 메커니즘

단순히 언어적인 측면에서 객체를 구별하던 REFERENCE OBJECT와 VALUE OBJECT의 개념을 넘어 인프라 스트럭쳐나 구현과 세부 구현과 관련된 문제도 함께 고려해야 한다.